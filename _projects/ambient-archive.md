---
layout: default
---

# Ambient Archive

Github: https://github.com/sebastienlarivee/music-uploader 

YouTube: https://www.youtube.com/@AmbientArchiveMusic

At the time of writing I feel that Stable Audio (SA) is the best generative audio AI available. I wanted to put its consistency to the test by seeing if it could be used to as part of a YouTube channel aimed at releasing ambient music. Also I wanted to have the releases be managed with as little human involvement as possible; that meant the song/album titles, release artwork, video creation, and file uploads should all be handled automatically. To this end I built a system combining python and AHK to comfortably run the channel while needing only around 10% of actions to be done manually.

The process looks like this:

1. Use an AHK script to automatically generate and download tracks from SA’s website. Unfortunately I’m forced to use their official site as the weights are not public, eventually this step will just happen through the command line as better models are released.

2. An AHK script runs each track through [PaulXStretch](https://sonosaurus.com/paulxstretch/) to bring their length from 90 seconds (max supported by SA) to roughly 6 minutes. I would probably still do this even if SA supported longer track times, as PaulXStretch is great for smoothing out the audio and making it sound more ‘ambient-y’. SHOW BEFORE AND AFTER HERE

3. Each track does a final pass through some basic EQ, silence trimming, and [Gullfoss](https://www.soundtheory.com/howto) automatic mixing inside of [Audacity](https://www.audacityteam.org/). Audacity has great support for bulk audio rendering and the whole process just takes a few clicks for hundreds of tracks. SHOW BEFORE AND AFTER HERE

4. I manually place the tracks inside of the ‘wavs’ folder in my project. I’ll also generate a bunch of 1080x1920 images in [Stable Diffusion](https://stability.ai/stable-diffusion) for release artwork, these are placed in the ‘pngs’ folder.

5. My code runs:
    1. It selects 12 track names from a list generated by ChatGPT, and a release date, then uses these to create a metadata file for the album.

    2. A folder named after the album title is created and twelve .wavs are pulled from the bulk wav folder and renamed according to the metadata file. One image is pulled from the png folder as well.

    3. A square version for streaming services of the artwork is created by selecting the brightest region of the rectangular image. And a thumbnail for YouTube is created by downsizing the png to less than 2mb. 
    - Code snippets:
        
    ```python
    # For streaming:
    def find_brightest_square(self, image):
            width, height = image.size
            max_brightness = 0
            brightest_square = None
            print("Cropper working...")
    
            for x in range(width - self.square_size + 1):
                for y in range(height - self.square_size + 1):
                    square = image.crop((x, y, x + self.square_size, y + self.square_size))
                    brightness = self.compute_brightness(square)
                    if brightness > max_brightness:
                        max_brightness = brightness
                        brightest_square = (x, y)
    
            return brightest_square
    
    # For YouTube thumbnail:
    def resize_image(self, scale_factor):
            image = Image.open(self.input_path)
            resized_width = int(image.width * scale_factor)
            resized_height = int(image.height * scale_factor)
            resized_image = image.resize((resized_width, resized_height))
            return resized_image
    
        def save_resized_image(self, output_path):
            scale_factor = 1.0
            print("Thumbnail resizer working...")
            while True:
                resized_image = self.resize_image(scale_factor)
    
                with io.BytesIO() as buffer:
                    resized_image.save(buffer, "PNG")
                    size_in_mb = len(buffer.getvalue()) / (1024 * 1024)
                    if size_in_mb <= self.max_mb:
                        with open(output_path, "wb") as f:
                            f.write(buffer.getvalue())
                        break
    
                scale_factor *= 0.98
    ```
            
    4. With the full size artwork a 1080p video for YouTube is rendered through the [MoviePy](https://pypi.org/project/moviepy/) library. As the visual content is just a still image. I sped up rendering and lowered file size by reducing the framerate to 1fps and by using a low video bitrate.
    5. A description is generated for YouTube which includes all the track playback times so YouTube can automatically generate [chapters](https://support.google.com/youtube/answer/9884579?hl=en) corresponding to each song. This description is then copyied to the clipboard.
    6. Finally, an AHK script script is generated which is used to automatically upload the album to [DistroKid](https://distrokid.com/), a platform which distributes music on streaming services. 
6. I run the new DistroKid AHK script and manually upload the video to YouTube. SHOW VIDEO OF DISTROKID UPLOAD